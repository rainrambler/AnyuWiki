- Password-authenticated key agreement
- 密码验证密钥建立 (PAKE) 是一种密码原语，它允许共享低熵秘密（密码）的两方在没有公钥基础设施的情况下安全地建立密码密钥。
-
- **Wiki:**
- 在密码学([[Cryptography]])中，密码验证密钥协商方法是一种交互方法，供两方或多方根据一方或多方对密码的了解来建立密码密钥。
  一个重要的特性是窃听者或中间人([[Man-in-the-middle attack]])无法获得足够的信息来暴力猜测密码，而无需针对每个（少数）猜测与各方进行进一步交互。 这意味着可以使用弱密码获得强大的安全性。
- 类型
- 密码认证的密钥协议通常包括以下方法：
	- 平衡的(Balanced)密码认证密钥交换
	- 增强的(Augmented)密码认证密钥交换
	- 密码认证的密钥检索
	- 多服务器方法
	- 多方方法
- 在最严格的纯密码安全模型中，该方法的用户不需要记住密码以外的任何秘密或公共数据。
- **密码验证密钥交换 (PAKE)** 是指两方或多方仅基于他们对共享密码的了解，使用交换消息来建立加密密钥，这样未经授权的一方（控制通信通道但不拥有密码）不能参与该方法，并尽可能地限制暴力猜测密码。 （最优情况每次运行交换只产生一个猜测。） PAKE 的两种形式是平衡方法和增强(Augmented)方法。
-
- 由  #IETF [[CFRG]] 进行标准化。
- 包括两种实现：[[CPace]] 和 [[OPAQUE]]。
-
- **Matthew Green:**
- PAKE协议是为了解决密码认证的问题。不管密码如何哈希、如何加盐、如何使用内存困难的哈希算法（如 [[scrypt]]或 [[Argon2]] ），最基本的问题是，认证时，用户传入的还是密码的明文。
- PAKE 协议首先由 Bellovin 和 Merritt 引入，是一种特殊形式的加密密钥交换([[Key exchange]] or [[Key-agreement protocol]] )协议。密钥交换（或“密钥协议”）协议旨在帮助两方（称他们为客户端和服务器）使用公钥密码术就共享密钥达成一致。最早的密钥交换协议——比如经典的 [[Diffie-Hellman]] ——是未经身份验证的，这使得它们容易受到中间人攻击。PAKE 协议的显着特征是客户端将**使用密码**向服务器验证自己。出于显而易见的原因，假设服务器已经知道密码或其哈希值，这就是允许检查的原因。
- 如果这就是我们所需要的，那么 PAKE 协议将很容易构建。PAKE 真正有用的是它还应该为客户的密码提供保护。这种保证的更强有力的版本可以表述如下：在登录尝试（有效或无效）之后，客户端和服务器都应该只了解客户端的密码是否与服务器的预期值匹配，而不需要额外的信息。这是一个强有力的保证。事实上，这与我们从零知识证明([[Zero-knowledge proof]])中要求的内容没有什么不同。
- 当然，PAKE 的明显问题是很多人一开始就不想运行“密钥交换”协议！他们只想验证用户是否知道密码。
- PAKE 的伟大之处在于更简单的“仅登录”用例很容易实现。如果我有一个标准的 PAKE 协议，当（且仅当）客户端知道正确的密码时，它允许客户端和服务器就共享密钥 K 达成一致，那么我们需要添加的只是一个简单的检查，即双方是否已达成一致钥匙。（例如，可以通过让各方使用它计算一些加密函数并检查结果来完成此操作。）因此，即使您只考虑密码检查，PAKE 也很有用。
- [[SRP]]：被时间遗忘的 PAKE
	- 与我们今天用来登录服务器的幼稚方法相比，PAKE 概念似乎提供了明显的安全优势。而且这些技术很古老，因为 PAKE 早在 1992 年就已为人所知！尽管如此，他们已经看到几乎没有采用。这是怎么回事？
	- 这有几个明显的原因。最明显的一点与网络的局限性有关：将密码表单放在网页上比在浏览器中进行花哨的加密要容易得多。但这种解释是不够的。即使是本机应用程序也很少为其登录实现 PAKE。另一个可能的解释与专利有关，尽管其中大部分已经过期。对我来说，PAKE 的持续缺席有两个可能的原因：（1）在有用的语言中**缺乏好的 PAKE 实现**，这使得使用起来很麻烦，（2）密码学家不善于**传达他们工作的价值**，所以大多数人甚至不知道 PAKE 是一种选择。
	- 尽管我说没有部署 PAKE，但规则也有一些例外。
	- 其中一个值得注意的是 1998 年由 Tom Wu [更正：不是 Tim Wu] 设计的协议，称为“SRP”。 “安全远程密码”的缩写，这是一个简单的三轮 PAKE，具有一些早期作品中没有的优雅功能。此外，SRP 的区别在于（据我所知）是世界上部署最广泛的 PAKE 协议。我引用了两个证据来证明这一说法：
	- SRP 已被标准化为 [[TLS]] 密码套件，并且实际上在 [[OpenSSL]] 等库中实现，尽管似乎没有人经常使用它。
	- [Apple](https://www.blackhat.com/docs/us-16/materials/us-16-Krstic.pdf) 在其 [[iCloud]] [[Key Vault]] 中广泛使用 SRP。
	- 第二个事实本身就可以使 SRP 成为世界上使用最广泛的加密协议之一，Apple 出货的设备数量如此庞大。所以这没什么好嘲笑的。
	- SRP 做了一些“正确”的事情。一方面，与早期的 PAKE 不同，它不需要您在服务器上存储原始密码（或者，等效地，可以被恶意客户端用来代替密码的哈希值）。相反，服务器存储一个“验证器”，它是密码哈希的单向函数。这意味着密码数据库的泄漏不会（立即）允许攻击者冒充用户——除非他们进行进一步昂贵的字典攻击。 （技术名称是“非对称”PAKE。）
	- 更好的是，当前版本的 SRP (v6a) 并没有明显破解！
	- 然而（并没有冒犯设计者）SRP 协议设计完全是疯狂的，早期版本已经被破解了好几次——这就是我们现在处于修订版 6a 的原因。加上原始研究论文中的“安全证明”并没有真正证明任何意义。
	- SRP 目前依赖于整数（有限域 [[Finite field]] ）算术，并且由于各种原因，该构造显然不能转移到椭圆曲线([[ECC]])设置。这需要更多的带宽和计算，因此 SRP 无法利用在 [[Curve25519]] 等设置中开发的许多效率改进。
	- SRP 容易受到预计算攻击([[Pre-computation Attack]])，因为它将用户的“盐”交给任何可以启动 SRP 会话的攻击者。这意味着我可以向服务器索要你的盐，甚至在服务器被破坏之前建立一个潜在密码哈希字典。
	- 尽管有所有这些缺点，SRP 很简单——而且实际上附带了工作代码。此外，OpenSSL 中的工作代码甚至与 TLS 集成，这使得它相对容易采用。
	- 在所有这些点中，最后一点几乎肯定是 SRP 与其他 PAKE 协议相比（相对）高度商业成功的原因。这并不理想，但它是真实的。这是密码学家要记住的事情。
- OPAQUE：新一代的 PAKE
	- 几个月前，当我开始考虑 PAKE 时，我不禁注意到大多数现有的工作都有些糟糕。它要么有 SRP 之类的奇怪问题，要么要求用户在服务器上存储密码（或有效密码），或者它向攻击者泄露了盐——允许预计算攻击。
	- 然后在今年早些时候，Jarecki、Krawczyk 和 Xu 提出了一种名为 OPAQUE 的新协议。OPAQUE 有许多非常好的优点：
	- 它可以在 Diffie-Hellman 和离散对数（类型）([[Discrete logarithm]])问题难以解决的任何环境中实现。这意味着，与 SRP 不同，它可以使用有效的椭圆曲线轻松实例化。
	- 更好的是：OPAQUE 不会向攻击者透露盐。它通过使用有效的“遗忘 PRF” (oblivious [[PRF]], [[Oblivious Pseudorandom Function]])将盐与密码结合起来解决了这个问题，以确保客户端不学习盐而服务器不学习密码。
	- OPAQUE 适用于任何密码散列函数。更好的是，由于所有哈希工作都在客户端完成，OPAQUE 实际上可以减轻服务器的负载，释放在线服务以使用更强大的安全设置——例如，使用大 RAM 参数配置 [[scrypt]]。
	- 在消息数量和求幂方面，OPAQUE 与 SRP 没有太大区别。但由于它可以在更高效的环境中实施，它可能会更有效率。
	- 与 SRP 不同，OPAQUE 具有合理的安全证明（在非常强大的模型中）。
-
- https://blog.cryptographyengineering.com/2018/10/19/lets-talk-about-pake/